<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>演算子 - とほほのWWW入門</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<link rel="stylesheet" href="../style3.css" tppabs="http://www.tohoho-web.com/style3.css">
</head>
<body>

<h2>演算子</h2>
<a href="index.htm" tppabs="http://www.tohoho-web.com/js/index.htm">[up]</a>
<a href="statement.htm" tppabs="http://www.tohoho-web.com/js/statement.htm">[prev]</a>
<a href="value.htm" tppabs="http://www.tohoho-web.com/js/value.htm">[next]</a>

<h4>一覧</h4>
<div class=i>
<a href="#and">&amp;&amp;</a>,
<a href="#aneq">&amp;=</a>,
<a href="#band">&amp;</a>,
<a href="#bnot">~</a>,
<a href="#bor"> | </a>,
<a href="#bxor">^</a>,
<a href="#comma">, </a>,
<a href="#cond">?  :</a>,
<a href="#nullish">??</a>,
<a href="#optional">?</a>,
<a href="#dec1">--</a>,
<a href="#dec2">--</a>,
<a href="#dieq">/=</a>,
<a href="#division">/</a>,
<a href="#eq">==</a>,
<a href="#eqq">===</a>,
<a href="#gt">&gt;</a>,
<a href="#gte">&gt;=</a>,
<a href="#inc1">++</a>,
<a href="#inc2">++</a>,
<a href="#lseq">&lt;&lt;=</a>,
<a href="#lshift">&lt;&lt;</a>,
<a href="#lt">&lt;</a>,
<a href="#lte">&lt;=</a>,
<a href="#mieq">-=</a>,
<a href="#minus">-</a>,
<a href="#mod">%</a>,
<a href="#moeq">%=</a>,
<a href="#multiple">*</a>,
<a href="#exp">**</a>,
<a href="#mueq">*=</a>,
<a href="#expeq">**=</a>,
<a href="#ne">!=</a>,
<a href="#neqq">!==</a>,
<a href="#noeq">^=</a>,
<a href="#not"> ! </a>,
<a href="#or">||</a>,
<a href="#oreq">|=</a>,
<a href="#pleq">+=</a>,
<a href="#plus">+</a>,
<a href="#rseq">&gt;&gt;=</a>,
<a href="#rshift">&gt;&gt;</a>,
<a href="#set">=</a>,
<a href="#urseq">&gt;&gt;&gt;=</a>,
<a href="#urshift">&gt;&gt;&gt;</a>
<a href="#delete">delete</a>
<a href="#in">in</a>
<a href="#instanceof">instanceof</a>
<a href="#typeof">typeof</a>
<a href="#void">void</a>
</div>

<h4 id="assignment">代入演算子</h4>

<h5 id="set">◆ <i>var</i> = <i>exp</i></h5>
<div class=i>
<p>変数 <i>var</i> に値 <i>exp</i> を代入します。イコール(=)は等しいという意味ではなく代入するという意味を持ちます。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
xx <em>=</em> 5;      <span class="comment">// xx に 5 を代入する</span>
yy <em>=</em> xx;     <span class="comment">// yy に xx の値(= 5)を代入する</span>
zz <em>=</em> "ABC";  <span class="comment">// zz に文字列"ABC"を代入する</span>
</pre>
<p>例えば、次の例を数学的に解釈すると「解無し」となってしまいますが、JavaScript ではこれを「xx という変数に、xx の値と 2 を足したものを代入する」という意味になります。あらかじめ xx に 5 が代入されていれば、xx は 7 となります。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
xx = xx + 2;  <span class="comment">// xx には xx に 2 を加えた値を代入する</span>
</pre>
<p>次の例で、「yy = xx = 5;」は、「yy = (xx = 5);」と解釈されます。ここで、「xx = 5」自体が代入された値を示すので。これにより、変数 yy にも値 5 が代入されることになります。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
yy = xx = 5;   <span class="comment">// yy と xx に 5 を代入する</span>
</pre>
</div>

<h4 id="arithmetic">算術演算子</h4>

<h5 id="plus">◆ <i>exp1</i> + <i>exp2</i></h5>
<h5 id="minus">◆ <i>exp1</i> - <i>exp2</i></h5>
<h5 id="multiple">◆ <i>exp1</i> * <i>exp2</i></h5>
<h5 id="division">◆ <i>exp1</i> / <i>exp2</i></h5>
<h5 id="mod">◆ <i>exp1</i> % <i>exp2</i></h5>
<h5 id="exp">◆ <i>exp1</i> ** <i>exp2</i></h5>
<div class=i>
<p><i>exp1</i> と <i>exp2</i> の足し算、引き算、掛け算、割り算などを行います。演算子 % は、<i>exp1</i> を <i>exp2</i> で割った余りを返します。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
xx = 3 <em>+</em> 2;   <span class="comment">// xx には 5 が代入されます</span>
xx = 3 <em>-</em> 2;   <span class="comment">// xx には 1 が代入されます</span>
xx = 3 <em>*</em> 2;   <span class="comment">// xx には 6 が代入されます</span>
xx = 3 <em>/</em> 2;   <span class="comment">// xx には 1.5 が代入されます</span>
xx = 3 <em>%</em> 2;   <span class="comment">// xx には 1 が代入されます</span>
</pre>
<p>** はべき乗を示します。<a href="what.htm#version" tppabs="http://www.tohoho-web.com/js/what.htm#version">ES2016</a> で追加された機能で、Chrome, Firefox, Edge, Opera, Safari ではサポートされていますが、Internet Explorer 11 ではサポートされていません。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
xx = 3 <em>**</em> 2;   <span class="comment">// xx には 9(3 の 2乗) が代入されます</span>
</pre>
<p>演算子 + を用いるときは注意が必要です。<i>exp1</i> と <i>exp2</i> のどちらか(もしくは両方)が文字列の場合は、算術演算子ではなく、文字列の連結演算子として機能するからです。例えば、次の例では、xx は 127 になりません。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
xx = "123" + 4;   <span class="comment">// xx には "1234" が代入されます</span>
</pre>
<p>フォームに入力した値も文字列として扱われるので注意が必要です。フォームの値を数値として扱いたいときは、<a href="builtin.htm#Number" tppabs="http://www.tohoho-web.com/js/builtin.htm#Number">Number()</a> などで数値に変換します。演算子 - は算術演算子としての機能しかないので、"123" から 3 を引いても "12" にはならず、120 になります。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
&lt;script&gt;
function func() {
  alert(document.form1.text1.value + 4);        <span class="comment">// "1234" になります</span>
  alert(Number(document.form1.text1.value) + 4);  <span class="comment">// 127 になります</span>
}
&lt;/script&gt;
&lt;form name="form1" action="#"&gt;
&lt;input type="text" name="text1" value="123"&gt;
&lt;input type="button" value="OK" onclick="func()"&gt;
&lt;/form&gt;
</pre>
</div>

<h5 id="inc1">◆ <i>var</i>++</h5>
<h5 id="inc2">◆ ++<i>var</i></h5>
<h5 id="dec1">◆ <i>var</i>--</h5>
<h5 id="dec2">◆ --<i>var</i></h5>
<div class=i>
<p>xx++ は xx の値をひとつ増やします。xx-- は xx の値をひとつ減らします。xx++ は、加算する前の値を返し、++xx は加算の後の値を返します。xx-- と --xx も同様です。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
a = 5; a<em>++</em>;     <span class="comment">// aの値は6となる</span>
a = 5; b = a<em>++</em>; <span class="comment">// aの値は6、bの値は5となる</span>
a = 5; b = <em>++</em>a; <span class="comment">// aの値は6、bの値は6となる</span>
</pre>
</div>

<h4 id="comparison">比較演算子</h4>

<h5 id="eq">◆ <i>exp1</i> == <i>exp2</i></h5>
<h5 id="ne">◆ <i>exp1</i> != <i>exp2</i></h5>
<div class=i>
<p>== 演算子は、<i>exp1</i> が <i>exp2</i> と等しければ true(真)、さもなくば false(偽) を返します。!= 演算子は、<i>exp1</i> と <i>exp2</i> が等しくなければ true(真)、さもなくば false(偽)を返します。数値にも文字列にも使用可能です。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
xx = 5;
if (xx <em>==</em> 5) {
  alert("xx is 5.");
}
if (xx <em>!=</em> 5) {
  alert("xx is not 5.");
}
</pre>
<p>数値を文字列を比較した場合は、暗黙の型変換が行われます。下記の例は等しいとみなされます。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
if ("123" <em>==</em> 123) {
  alert("等しい");
}
</pre>
</div>

<h5 id="lt">◆ <i>exp1</i> &lt; <i>exp2</i></h5>
<h5 id="lte">◆ <i>exp1</i> &lt;= <i>exp2</i></h5>
<h5 id="gt">◆ <i>exp1</i> &gt; <i>exp2</i></h5>
<h5 id="gte">◆ <i>exp1</i> &gt;= <i>exp2</i></h5>
<div class=i>
<p><i>exp1</i> が <i>exp2</i> の大きさを比較してその結果を true(真) または false(偽) で返します。演算子はそれぞれ、より小さい(&lt;)、以下(&lt;=)、より大きい(&gt;)、以上(&gt;=) を意味します。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
if (xx <em>&lt;</em> 123) {
  alert("xx は 123 より小さいです。");
}
</pre>
<p>これらの演算子を文字列に対して使用した場合は、辞書順の前後比較を行います。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
if (xx <em>&lt;</em> "H") {
  alert("xx は H よりも前にあります。");
}
</pre>
</div>

<h5 id="eqq">◆ <i>exp1</i> === <i>exp2</i></h5>
<h5 id="neqq">◆ <i>exp1</i> !== <i>exp2</i></h5>
<div class=i>
<p>数値と文字列を比較したときに、== 演算子や != 演算子が暗黙の型変換を行うのに対し、=== 演算子や !== 演算子は数値と文字列は常に異なるものと判断します。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
if ( 123  <em>==</em>   123 ) { ... }    <span class="comment">// true(真)</span>
if ("123" <em>==</em>  "123") { ... }    <span class="comment">// true(真)</span>
if ("123" <em>==</em>   123 ) { ... }    <span class="comment">// true(真)</span>
if ( 123  <em>==</em>  "123") { ... }    <span class="comment">// true(真)</span>
if ( 123  <em>===</em>  123 ) { ... }    <span class="comment">// true(真)</span>
if ("123" <em>===</em> "123") { ... }    <span class="comment">// true(真)</span>
if ("123" <em>===</em>  123 ) { ... }    <span class="comment">// false(偽)</span>
if ( 123  <em>===</em> "123") { ... }    <span class="comment">// false(偽)</span>
</pre>
</div>

<h4 id="logical">論理演算子</h4>

<h5 id="and">◆ <i>exp1</i> &amp;&amp; <i>exp2</i></h5>
<div class=i>
<p><i>exp1</i> が真、かつ、<i>exp2</i> が真であれば真を、さもなければ偽を返します。下記の例では、mon が 1 以上であり、かつ、mon が 12 以下の時に真となります。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
if ((1 &lt;= mon) <em>&amp;&amp;</em> (mon &lt;= 12)) {
  alert("xx is between 1 and 12.");
}
</pre>
</div>

<h5 id="or">◆ <i>exp1</i> || <i>exp2</i></h5>
<div class=i>
<p><i>exp1</i> が真、または、<i>exp2</i> が真であれば真を返します。下記の例では、xx が "ABC" である、または、xx が "abc" である場合に真となります。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
if ((xx == "ABC") <em>||</em> (xx == "abc")) {
  alert("xx is ABC.");
}
</pre>
</div>

<h5 id="not">◆ !<i>exp1</i></h5>
<div class=i>
<p><i>exp1</i> が真ではない時に真を返します。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
if (<em>!</em>(xx == 5)) {
  alert("xx is not five.");
}
</pre>
</div>

<h4 id="conditional">条件演算子</h4>

<h5 id="cond">◆ <i>exp1</i> ? <i>exp2</i> : <i>exp3</i></h5>
<div class=i>
<p><i>exp1</i> が真であれば <i>exp2</i> を、さもなくば <i>exp3</i> を返します。次の例は xx が 5 以上であれば "big"、さもなくば "small" を yy に代入します。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
yy = (xx &gt;= 5) <em>?</em> "big" <em>:</em> "small";
</pre>
</div>

<h4 id="commaop">カンマ演算子</h4>

<h5 id="comma">◆ <i>exp1</i>, <i>exp2</i></h5>
<div class=i>
<p>常に <i>exp2</i> の値を返します。ただし、代入演算子(=など)よりも優先度が低いため、xx = 1, 2; は (xx = 1), 2; と解釈されるので注意してください。また、関数の引数にカンマ(,)を用いた場合は、カンマ演算子とは解釈されません。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
for (i = 0<em>,</em> j = 0; i &lt; 10; i++) {
  :
}
</pre>
</div>

<h4 id="bitwise">ビット演算子</h4>

<h5 id="band">◆ <i>exp1</i> &amp; <i>exp2</i></h5>
<h5 id="bor">◆ <i>exp1</i> | <i>exp2</i></h5>
<h5 id="bxor">◆ <i>exp1</i> ^ <i>exp2</i></h5>
<h5 id="bnot">◆ ~<i>exp1</i></h5>
<div class=i>
<p><i>exp1</i> と <i>exp2</i> を4バイト整数と見なして、それぞれ、AND(&amp;)、OR(|)、XOR(^)、NOT(~)演算を行った結果を返します。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
xx = 0x87654321 <em>&amp;</em> 0xffff0000;  <span class="comment">// xx には 0x87650000 が代入される</span>
xx = 0x87654321 <em>|</em> 0xffff0000;  <span class="comment">// xx には 0xffff4321 が代入される</span>
xx = 0xffff0000 <em>^</em> 0xff00ff00;  <span class="comment">// xx には 0x00ffff00 が代入される</span>
xx = <em>~</em>0xffff0000;              <span class="comment">// xx には 0x0000ffff が代入される</span>
</pre>
</div>

<h5 id="lshift">◆ <i>exp1</i> &lt;&lt; <i>exp2</i></h5>
<h5 id="rshift">◆ <i>exp1</i> &gt;&gt; <i>exp2</i></h5>
<h5 id="urshift">◆ <i>exp1</i> &gt;&gt;&gt; <i>exp2</i></h5>
<div class=i>
<p><i>exp1</i> を4バイト整数と見なして、<i>exp1</i> を <i>exp2</i> ビット分、左シフト(&lt;&lt;)、右シフト(&gt;&gt;)、0埋め右シフト(&gt;&gt;&gt;)した結果を返します。&gt;&gt; の場合は左端には最上位のビットが埋められますが、&gt;&gt;&gt; は常に 0 が埋められます。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
xx = 0x12345678 <em>&lt;&lt;</em> 8;  <span class="comment">// xx には 0x34567800 が代入される</span>
xx = 0x12345678 <em>&gt;&gt;</em> 8;  <span class="comment">// xx には 0x00123456 が代入される</span>
xx = 0x87654321 <em>&gt;&gt;</em> 8;  <span class="comment">// xx には 0xff876543 が代入される</span>
xx = 0x87654321 <em>&gt;&gt;&gt;</em> 8; <span class="comment">// xx には 0x00876543 が代入される</span>
</pre>
</div>

<h4 id="arithAssignment">複合代入演算子</h4>

<h5 id="pleq">◆ <i>var</i> += <i>exp</i></h5>
<h5 id="mieq">◆ <i>var</i> -= <i>exp</i></h5>
<h5 id="mueq">◆ <i>var</i> *= <i>exp</i></h5>
<h5 id="dieq">◆ <i>var</i> /= <i>exp</i></h5>
<h5 id="moeq">◆ <i>var</i> %= <i>exp</i></h5>
<h5 id="expeq">◆ <i>var</i> **= <i>exp</i></h5>
<h5 id="aneq">◆ <i>var</i> &amp;= <i>exp</i></h5>
<h5 id="oreq">◆ <i>var</i> |= <i>exp</i></h5>
<h5 id="noeq">◆ <i>var</i> ^= <i>exp</i></h5>
<h5 id="lseq">◆ <i>var</i> &lt;&lt;= <i>exp</i></h5>
<h5 id="rseq">◆ <i>var</i> &gt;&gt;= <i>exp</i></h5>
<h5 id="urseq">◆ <i>var</i> &gt;&gt;&gt;= <i>exp</i></h5>
<div class=i>
<p>例えば、xx += 5; は xx = xx + 5; と同じような動作をします。同様に、xx -= 5; は xx = xx - 5; と同じような動作をします。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
xx <em>+=</em> 5;    <span class="comment">// xx = xx + 5; と同じ</span>
xx <em>-=</em> 5;    <span class="comment">// xx = xx - 5; と同じ</span>
xx <em>*=</em> 5;    <span class="comment">// xx = xx * 5; と同じ</span>
xx <em>/=</em> 5;    <span class="comment">// xx = xx / 5; と同じ</span>
xx <em>%=</em> 5;    <span class="comment">// xx = xx % 5; と同じ</span>
xx <em>**=</em> 5;    <span class="comment">// xx = xx ** 5; と同じ (Internet Explorer 11 では未サポート)</span>
xx <em>&amp;=</em> 0xff; <span class="comment">// xx = xx &amp; 0xff; と同じ</span>
xx <em>|=</em> 0xff; <span class="comment">// xx = xx | 0xff; と同じ</span>
xx <em>^=</em> 0xff; <span class="comment">// xx = xx ^ 0xff; と同じ</span>
xx <em>&lt;&lt;=</em> 8;   <span class="comment">// xx = xx &lt;&lt; 8; と同じ</span>
xx <em>&gt;&gt;=</em> 8;   <span class="comment">// xx = xx &gt;&gt; 8; と同じ</span>
xx <em>&gt;&gt;&gt;=</em> 8;  <span class="comment">// xx = xx &gt;&gt;&gt; 8; と同じ</span>
</pre>
</div>

<h4 id="null">ヌル値関連演算子</h4>

<h5 id="nullish">◆ <i>var</i> ?? <i>exp</i></h5>
<div class="i">
<p>Nullish Coalescing(ヌル合体)演算子と呼ばれます。<i>var</i> が null や undefined の場合は <i>exp</i> を、さもなくば <i>var</i> の値を返します。値が省略された場合のデフォルト値を設定するのに便利です。<a href="what.htm#es2020" tppabs="http://www.tohoho-web.com/js/what.htm#es2020">ES2020</a> で追加されました。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
<span class="cm">// 古い書き方(obj.fooが未設定の場合デフォルト値60を設定する)</span>
if (typeof(obj.foo) == "undefined" || obj.foo == null) {
    obj.foo = 60;
}

<span class="cm">// ES2020以降の新しい書き方</span>
obj.foo = obj.foo <em>??</em> 60;
</pre>
</div>

<h5 id="optional">◆ <i>var</i>?.<i>attr</i></h5>
<div class="i">
<p>Optional Chaining(オプショナル連結)と呼ばれます。<i>var</i> が null や undefined の場合でも TypeError になることなく、undefined を返します。<a href="what.htm#es2020" tppabs="http://www.tohoho-web.com/js/what.htm#es2020">ES2020</a> で追加されました。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
<span class="cm">// これまでの書き方</span>
if (response.body) {			<span class="cm">// body が存在することを確認してから</span>
  console.log(response.body.length);	<span class="cm">// その属性にアクセスする</span>
}

<span class="cm">// ES2020以降の書き方</span>
console.log(response.body<em>?</em>.length);	<span class="cm">// =&gt; body が存在すれば length 値を、さもなくば undefined</span>
</pre>
</div>

<h4 id="other">その他の演算子</h4>

<h5 id="delete">◆ delete <i>expression</i></h5>
<div class=i>
<p>delete 演算子は、<i>expression</i> で指定した、グローバル変数やオブジェクトのプロパティを削除します。<a href="basic.htm" tppabs="http://www.tohoho-web.com/js/basic.htm">var</a> で明示的に定義した変数は削除できませんが、var 無しに暗黙的に定義した変数は削除することができます。delete はオブジェクトのプロパティを削除する演算子であって、オブジェクト自体を削除することはできません。オブジェクトは、参照されるものが無くなった時点でガベジコレクション時に自動的に消去されます。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
var obj = {
  name: "Yamada",
  age: 24
};
console.log(obj.name);    <span class="comment">// Yamada</span>
<em>delete</em> obj.name;
console.log(obj.name);    <span class="comment">// undefined</span>
</pre>
</div>

<h5 id="typeof">◆ typeof <i>expression</i></h5>
<div class=i>
<p>typeof 演算子は、<i>expression</i> で与えられた値の型を示す文字列を返します。typeof(null) は本来 "null" を返すべきかもしれませんが、歴史的な理由により "object" を返します。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
<em>typeof(</em>undefined<em>)</em>      <span class="comment">// "undefined"</span>
<em>typeof(</em>null<em>)</em>           <span class="comment">// "object"</span>
<em>typeof(</em>true<em>)</em>           <span class="comment">// "boolean"</span>
<em>typeof(</em>"abc"<em>)</em>          <span class="comment">// "string"</span>
<em>typeof(</em>123.45<em>)</em>         <span class="comment">// "number"</span>
<em>typeof(</em>new Object()<em>)</em>   <span class="comment">// "object"</span>
<em>typeof(</em>function() {}<em>)</em>  <span class="comment">// "function"</span>
<em>typeof(</em>Symbol()<em>)</em>       <span class="comment">// "symbol"</span>
</pre>
</div>

<h5 id="void">◆ void <i>expression</i></h5>
<div class=i>
<p>void 演算子は、<i>expression</i> で指定された式に関わらず、常に undefined を返します。関数の戻り値を常に undefined にする場合などに用いられます。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
<em>void</em> function func() {
  alert("Hello!");
}
</pre>
<p>また、&lt;a href="javascript:～"&gt; で、何も実行するものが無い場合などに使用されることがあります。void() の代わりに直接 undefined を記述してもよいのですが、undefined という変数が上書きされてしまうリスクを回避するために、void(0) を使用することが多いようです。
<div class="title-tab">HTML</div>
<pre class=c2>
&lt;a href="javascript:<em>void(0)</em>"&gt;～&lt;/a&gt;
</pre>
</div>

<h5 id="in">◆ <i>expression</i> in <i>object</i></h5>
<div class=i>
<p>in 演算子は、<i>expression</i> が <i>object</i> で示されるオブジェクトのプロパティに存在するか否かを調べます。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
if ("appName" <em>in</em> navigator) {
  console.log("Yes");
}
</pre>
<div class="title-tab">JavaScript</div>
<pre class=c2>
p1 = {
  name:"Yamada",
  age:26
};
if ("name" <em>in</em> p1) {
  console.log("Yes");
}
</pre>
</div>

<h5 id="instanceof">◆ <i>expression</i> instanceof <i>objecttype</i></h5>
<div class=i>
<p>instanceof 演算子は、<i>expression</i> が <i>objecttype</i> で示されるオブジェクトか否かを調べます。下記の例では、p1 は Person オブジェクトであるため、true となり、Yes が表示されます。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
function Person() {}
var p1 = new Person();
if (p1 <em>instanceof</em> Person) {
  console.log("Yes");
} else {
  console.log("No");
}
</pre>
</div>

<h4 id="precedence">演算子の優先順位</h4>
<div class=i>
<p>各演算子の優先順位は以下のようになります。同じレベルの演算子は、式の左側にある方が優先度が高くなります。たとえば下記の例で、(式1) は (式2) と解釈されて答えは 13 となります。しかし、バグを埋め込まないためにも、優先順位が直感的に解らない個所には(たとえ無駄であっても)括弧をつけて、優先度を明示的に指定してやることをおすすめします。</p>
<div class="title-tab">JavaScript</div>
<pre class=c2>
(式1) xx = 3 + 4 * 5 / 2;
(式2) xx = 3 + ((4 * 5) / 2);
</pre>
<table class="tb1">
<tr class=h><th>優先度</th><th>演算子</th></tr>
<tr><th rowspan=15 class=h><div>↑</div><div>高い</div><br><br><br><div>低い</div><div>↓</div></th>
<td>配列([]) 括弧(( ))</td></tr>
<tr><td>増減(++ --) マイナス(-) 反転(~) NOT(!)</td></tr>
<tr><td>乗除余(* / %)</td></tr>
<tr><td>加減(+ -) 文字列連結(+)</td></tr>
<tr><td>シフト(&lt;&lt; &gt;&gt; &lt;&lt;&lt;)</td></tr>
<tr><td>比較(&lt; &lt;= &gt;= &gt;)</td></tr>
<tr><td>比較(== != === !==)</td></tr>
<tr><td>AND(&amp;)</td></tr>
<tr><td>XOR(^)</td></tr>
<tr><td>OR(|)</td></tr>
<tr><td>かつ(&amp;&amp;)</td></tr>
<tr><td>または(||)</td></tr>
<tr><td>二項(? :)</td></tr>
<tr><td>代入(=) 複合代入(+=など)</td></tr>
<tr><td>カンマ(,)</td></tr>
</table>
</div>

<hr>
<a href="index.htm" tppabs="http://www.tohoho-web.com/js/index.htm">[up]</a>
<a href="statement.htm" tppabs="http://www.tohoho-web.com/js/statement.htm">[prev]</a>
<a href="value.htm" tppabs="http://www.tohoho-web.com/js/value.htm">[next]</a>
<div>Copyright (C) 1996-2020 杜甫々</div>
<div>改訂版初版：2001年9月8日、最終更新：2020年12月27日</div>
<div>http://www.tohoho-web.com/js/operator.htm</div>
</body>
</html>
