<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8"utf-8">
<title>とほほのScala入門 - とほほのWWW入門</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<link rel="stylesheet" href="../style3.css" tppabs="http://www.tohoho-web.com/style3.css">
</head>
<body>

<h2>とほほのScala入門</h2>
<a href="../www.htm" tppabs="http://www.tohoho-web.com/www.htm">トップ</a> &gt;
とほほのScala入門

<h4 id="index">目次</h4>
<div class="i">
<ul>
<li><a href="#what">Scalaとは</a>
<li><a href="#install">インストール</a>
<li><a href="#hello_world">Hello world!</a>
<li><a href="#comments">コメント</a>
<li><a href="#keywords">キーワード</a>
<li><a href="#types">型</a>
  <ul>
  <li><a href="#boolean">真偽値(Boolean)</a>
  <li><a href="#char">文字(Char)</a>
  <li><a href="#string">文字列(String)</a>
  <li><a href="#integer">整数(Byte, Short, Int, Long)</a>
  <li><a href="#bigint">任意精度整数(BigInt)</a>
  <li><a href="#floating_point_number">浮動小数点数(Float, Double, BigDecimal)</a>
  <li><a href="#symbol">シンボル(Symbol)</a>
  <li><a href="#unit">ユニット(Unit)</a>
  <li><a href="#any">任意型(Any)</a>
  <li><a href="#anyval">任意値型(AnyVal)</a>
  <li><a href="#anyref">任意参照型(AnyRef)</a>
  <li><a href="#option">オプション(Option)</a>
  <li><a href="#array">配列(Array)</a>
  <li><a href="#list">リスト(List)</a>
  <li><a href="#map">マップ(Map)</a>
  <li><a href="#set">セット(Set)</a>
  <li><a href="#trait">タプル(TupleN)</a>
  <li><a href="#type">型別名(type)</a>
  <li><a href="#isinstanceof">クラス判定(isInstanceOf)</a>
  <li><a href="#asinstanceof">キャスト(asInstanceOf)</a>
</ul>
<li><a href="#operators">演算子</a>
<li><a href="#val_and_var">値(val)と変数(var)</a>
<li><a href="#statement_and_expression">文と式</a>
  <ul>
  <li><a href="#block">ブロック式</a>
  <li><a href="#if">if式</a>
  <li><a href="#while">while式</a>
  <li><a href="#do">do～while式</a>
  <li><a href="#for">for式</a>
  <li><a href="#match">マッチ式(match)</a>
  <li><a href="#try_catch">例外処理(throw, try, catch, finally)</a>
  </ul>
<li><a href="#function">関数(=&gt;)</a>
<li><a href="#method">メソッド(def)</a>
<li><a href="#higher-order">高階関数</a>
<li><a href="#by-name_parameters">名前渡しパラメータ</a>
<li><a href="#class">クラス(class)</a>
  <ul>
  <li><a href="#extends">クラスの継承(extends)</a>
  <li><a href="#final">クラス継承の禁止(final, sealed)</a>
  <li><a href="#abstract">抽象クラス(abstract)</a>
  <li><a href="#type_parameter">型パラメータ</a>
  <li><a href="#case">ケースクラス(case)</a>
  </ul>
<li><a href="#object">オブジェクト(object)</a>
<li><a href="#companion_object">コンパニオンオブジェクト</a>
<li><a href="#apply">ファクトリメソッド(apply())</a>
<li><a href="#unapply">抽出子(unapply())</a>
<li><a href="#trait">トレイト(trait)</a>
<li><a href="#mixin">ミックスイン(with)</a>
<li><a href="#implicit_conversion">暗黙の型変換(implicit)</a>
<li><a href="#implicit_parameter">暗黙のパラメータ(implicit)</a>
<li><a href="#lazy">遅延評価(lazy)</a>
<li><a href="#package">パッケージ(package)</a>
<li><a href="#import">インポート(import)</a>
<li><a href="#variant">非変・共変・反変</a>
<li><a href="#type_bounds">上限型境界と下限型境界</a>
<li><a href="#annotation">アノテーション(@～)</a>
<li><a href="#curry_and_partial">カリー化と部分適用</a>
<li><a href="#links">リンク</a>
</ul>
</div>

<h4 id="what">Scalaとは</h4>
<div class="i">
<ul>
<li>オブジェクト指向型言語と関数型言語の特徴を併せ持つマルチパラダイムプログラミング言語です。
<li>Scalable language が名前の由来です。
<li>小規模から大規模プロジェクトをサポートするスケーラブルな言語は、オブジェクト指向型と関数型の両方のメリットを兼ね備えていなくてはならないという設計思想から生まれました。
<li>Java の仮想マシン上で動作します。
<li>スイス連邦工科大学(EPFL)のマーティン・オーダスキー教授によって設計されました。
<li>Boolean や Int などすべての値がオブジェクトとして定義されています。
</ul>
</div>

<h4 id="install">インストール</h4>
<div class="i">
<p>Scala のインストール方法を下記に示します。</p>
<pre class="c">
<span class="cm"># CentOS 8</span>
# <em>dnf -y install scala</em>
# scala -version
Scala code runner version 2.10.6 -- Copyright 2002-2013, LAMP/EPFL
</pre>
</div>

<h4 id="hello_world">Hello world!</h4>
<div class="i">
<p>Hello world! を表示するプログラムは下記の様になります。拡張子は <b>.scala</b> です。</p>
<pre class="c">
object hello {
  def main(args: Array[String]) {
    println("Hello world!")
  }
}
</pre>
<p>コンパイルには <b>scalac</b> コマンドを、実行には <b>scala</b> コマンドを使用します。</p>
<pre class="c">
# <em>scalac hello.scala</em>
# <em>scala hello</em>
Hello world!
</pre>
</div>

<h4 id="comments">コメント</h4>
<div class="i">
<p>コメントには単行コメント <b>//</b> と複数行コメント <b>/*</b> ... <b>*/</b> を使用できます。</p>
<pre class="c">
<em>//</em> 単行コメント

<em>/*</em>
 * 複数行コメント
<em> */</em>
</pre>
</div>

<h4 id="keywords">キーワード</h4>
<div class="i">
<p>Scala のキーワード(予約語)には下記があります。</p>
<pre class="c">
<a href="#abstract">abstract</a>	<a href="#match">case</a>		<a href="#try_catch">catch</a>		<a href="#class">class</a>
<a href="#method">def</a>		<a href="#do">do</a>		<a href="#if">else</a>		<a href="#extends">extends</a>
<a href="#types">false</a>		<a href="#final">final</a>		<a href="#try_catch">finally</a>		<a href="#for">for</a>
forSome		<a href="#if">if</a>		<a href="#implicit_conversion">implicit</a>	<a href="#import">import</a>
<a href="#lazy">lazy</a>		macro		<a href="#match">match</a>		<a href="#class">new</a>
<a href="#option">null</a>		<a href="#object">object</a>		<a href="#extends">override</a>	<a href="#package">package</a>
<a href="#access_modifires">private</a>		<a href="#access_modifires">protected</a>	<a href="#method">return</a>		<a href="#final">sealed</a>
<a href="#super">super</a>		<a href="#method">this</a>		<a href="#try_catch">throw</a>		<a href="#trait">trait</a>
<a href="#try_catch">try</a>		<a href="#types">true</a>		<a href="#type">type</a>		<a href="#val_and_var">val</a>
<a href="#val_and_var">var</a>		<a href="#while">while</a>		<a href="#trait">with</a>		<a href="#for">yield</a>
_		:		=		<a href="#function">=&gt;</a>
<a href="#for">&lt;-</a>		<a href="#type_bounds">&lt;:</a>		&lt;%		<a href="#type_bounds">&gt;:</a>
#		<a href="#annotation">@</a>
</pre>
<p><b>forSome</b> は存在型を構成するものですが Scala 3.0 で廃止の予定です。</p>
</div>

<h4 id="types">型</h4>
<div class="i">
<p>下記などの型があります。</p>
<pre class="c">
<a href="#boolean">Boolean</a>		真偽値(true|false)
<a href="#char">Char</a>		文字('a')
<a href="#string">String</a>		文字列("ABC")
<a href="#integer">Byte</a>		8ビット整数(127)
<a href="#integer">Short</a>		16ビット整数(32767)
<a href="#integer">Int</a>		32ビット整数(2147483647)
<a href="#integer">Long</a>		64ビット整数(9223372036854775807L)
<a href="#bigint">BigInt</a>		任意精度整数
<a href="#floating_point_number">Float</a>		32ビット浮動小数点数(1.2f)
<a href="#floating_point_number">Double</a>		64ビット浮動小数点数(1.2e3)
<a href="#floating_point_number">BigDecimal</a>	任意精度浮動小数点数
<a href="#symbol">Symbol</a>		シンボル
<a href="#unit">Unit</a>		ユニット (())
<a href="#any">Any</a>		任意型(Any)
<a href="#option">Option</a>		オプション
</pre>
</div>

<h4 id="boolean">真偽値(Boolean)</h4>
<div class="i">
<p><b>Boolean</b> は真偽値を表す型です。<b>true</b> または <b>false</b> の値を持ちます。</p>
<pre class="c">
val b1: <em>Boolean</em> = <em>true</em>
val b2: <em>Boolean</em> = <em>false</em>
</pre>
</div>

<h4 id="char">文字(Char)</h4>
<div class="i">
<p><b>Char</b> は1文字を表す型です。文字は <b>'</b>...<b>'</b> で囲みます。</p>
<pre class="c">
val c1: <em>Char</em> = 'a'
val c2: <em>Char</em> = 'あ'
</pre>
<p>バックスラッシュ(\)は特別な意味を持ち、下記などのエスケープシーケンスを利用できます。</p>
<pre class="c">
\\		<span class="cm">// バックスラッシュ(\)</span>
\'		<span class="cm">// シングルクォーテーション(')</span>
\"		<span class="cm">// ダブルクォーテーション(")</span>
\n		<span class="cm">// 改行(LF)</span>
\r		<span class="cm">// 復帰(CR)</span>
\t		<span class="cm">// タブ(TAB)</span>
\b		<span class="cm">// バックスペース(BS)</span>
\f		<span class="cm">// フォームフィード(FF)</span>
\301		<span class="cm">// 文字コード(8進数)</span>
</pre>
<p>Unicode を扱うことができます。ただし Char で扱えるのは U+0000～U+FFFF の範囲で、U+10000～U+10FFFF 領域の文字はサロゲートペアとして2つのCharを用いて表す必要があります。</p>
<pre class="c">
\u3042		<span class="cm">// 文字コード(\u0000～\uFFFFのUnicode)</span>
\uD842\uDFB7	<span class="cm">// 文字コード(サロゲートペア) ... 1つのCharでは扱えない</span>
</pre>
</div>

<h4 id="string">文字列(String)</h4>
<div class="i">
<p><b>String</b> は文字列を表す型です。文字列は <b>"</b>...<b>"</b> で囲みます。エスケープシーケンスも利用できます。</p>
<pre class="c">
val s1: <em>String</em> = "ABCDEFG"
</pre>
<p><b>s補完子</b>(<b>s"</b>...<b>"</b>) を用いて、文字列の中に変数や式を埋め込むことができます。</p>
<pre class="c">
val name = "Yamada"
println(<em>s</em>"His name is <em>$name</em>. <em>${name}</em> is <em>${12 + 14}</em> years old.")
</pre>
<p><b>f補完子</b>(<b>f"</b>...<b>"</b>) を用いて、フォーマットを指定することができます。%05d は 0埋め5桁の10進数を意味します。</p>
<pre class="c">
val num = 123
println(<em>f</em>"${num}<em>%05d</em>")		<span class="cm">// =&gt; 00123</span>
</pre>
<p><b>raw補完子</b>(<b>raw"</b>...<b>"</b>) を用いると、バックスラッシュ(\)やダブルクォート(")がメタ文字ではなく通常文字として扱われるようになります。<b>raw"</b>...<b>"</b> の代わりに <b>"""</b>...<b>"""</b> と表現することもできます。正規表現を記述する際などによく使われます。</p>
<pre class="c">
println("ABC\nDEF")		<span class="cm">// ABC(改行)DEF</span>
println(<em>raw"</em>ABC\nDEF<em>"</em>)		<span class="cm">// ABC\nDEF</span>
println(<em>"""</em>ABC\nDEF<em>"""</em>)		<span class="cm">// ABC\nDEF</span>
</pre>
<p>raw文字列の中では改行コードを含めることができます。<b>stripMargin</b> メソッドを用いると行の先頭位置を揃えることができます。</p>
<pre class="c">
println("""This is Japan.
That is America.""")

println("""This is Japan.
          <em>|</em>That is America."""<em>.stripMargin</em>)
</pre>
</div>

<h4 id="integer">整数(Byte, Short, Int, Long)</h4>
<div class="i">
<p><b>Byte</b> は8ビット整数(-128～127)、<b>Short</b> は16ビット整数(-32768～32767)、<b>Int</b> は32ビット整数(-2147483648～2147483647)、<b>Long</b> は64ビット整数(-2^63～2^63-1) を表します。64ビット整数の末尾には L または l(小文字のL) をつけます。</p>
<pre class="c">
val a1: <em>Byte</em> = 127
val a2: <em>Short</em> = 32767
val a3: <em>Int</em> = 2147483647
val a4: <em>Long</em> = 9223372036854775807<em>L</em>
</pre>
</div>

<h4 id="bigint">任意精度整数(BigInt)</h4>
<div class="i">
<p><b>BigInt</b> は任意の精度を持つ整数です。64ビットを超える整数を丸め誤差なしで扱うことができます。</p>
<pre class="c">
val b1: <em>BigInt</em> = BigInt(9223372036854775807L)
val b2: <em>BigInt</em> = b1 + b1
println(b2)		<span class="cm">// =&gt; 18446744073709551614</span>
</pre>
</div>

<h4 id="floating_point_number">浮動小数点数(Float, Double, BigDecimal)</h4>
<div class="i">
<p><b>Float</b> は32ビット浮動小数点数、<b>Double</b> は64ビット浮動小数点数、<b>BigDecimal</b> は任意精度の浮動小数点数を表します。Float整数には末尾に <b>F</b> または <b>f</b> をつけます(必須)、Double整数には末尾に <b>D</b> または <b>d</b> をつけます(省略可能)。</p>
<pre class="c">
val a1: <em>Float</em> = 1.2f			<span class="cm">// 1.2 のFloat型</span>
val a3: <em>Double</em> = 1.2e3			<span class="cm">// 1.2×10<sup>3</sup></span>
val a3: <em>BigDecimal</em> = BigDecimal(1.2e99)	<span class="cm">// 1.2×10<sup>99</sup></span>
</pre>
</div>

<h4 id="symbol">シンボル(Symbol)</h4>
<div class="i">
<p>文字列は、同じ文字であってもそれぞれ値が等しい別のオブジェクトとして生成されますが、シンボル(<b>Symbol</b>)は、同じ文字のものは同じオブジェクトとして参照されます。<b>'</b>英数字 または <b>Symbol(</b>英数字文字列<b>)</b> で表します。String に比べて比較などのコストが低いため、マップのキーなどで利用されていたりもしましたが、Scala 3.0 で廃止の方向だそうです。</p>
<pre class="c">
val s1: <em>Symbol</em> = 'ABC
val s2: <em>Symbol</em> = Symbol("ABC")
</pre>
</div>

<h4 id="unit">ユニット(Unit)</h4>
<div class="i">
<p><b>Unit</b> は何もないことを示す型です。0個要素の <a href="#tuple">タプル</a> () が唯一の値となります。結果を返す必要のないメソッドの型を Unit にすることがよくあります。</p>
<pre class="c">
def log(str: String): <em>Unit</em> = {
  ...
}
</pre>
</div>

<h4 id="any">任意型(Any)</h4>
<div class="i">
<p><b>Any</b> は全ての型の親クラスであり、任意の型を保持する型としても利用できます。</p>
<pre class="c">
val v1: <em>Any</em> = 123
val v2: <em>Any</em> = "ABC"
</pre>
</div>

<h4 id="anyval">任意値型(AnyVal)</h4>
<div class="i">
<p><b>AnyVal</b> は <b>Any</b> のサブクラスであり、<b>Boolean</b>, <b>Int</b>, <b>Float</b>, <b>Unit</b> などの親クラスです。</p>
<pre class="c">
var n1: <em>AnyVal</em> = 123
var n2: <em>AnyVal</em> = 12.3
</pre>
</div>

<h4 id="anyref">任意参照型(AnyRef)</h4>
<div class="i">
<p><b>AnyRef</b> は <b>Any</b> のサブクラスであり、<b>String</b> などの親クラスです。<b>AnyRef</b> のサブクラスは値として <b>null</b> をもつことができます。</p>
<pre class="c">
var s: <em>AnyRef</em> = "ABC"
</pre>
</div>

<h4 id="option">オプション(Option)</h4>
<div class="i">
<p><b>Option</b> は値が存在しないケースを含む際に使用される型です。<b>Option[</b>型名<b>]</b> は、値が存在する場合は <b>Some(</b>値<b>)</b>、値が存在しない場合は <b>None</b> となります。<b>None</b> と <b>null</b> は別物です。<b>String</b> 型変数は <b>null</b> になることができますが、<b>Int</b> 型変数は <b>null</b> になることができません。例えば、下記の例で <b>map.get(</b>n<b>)</b> は、<b>Option[Any]</b> 型のメソッドで、n が 1 であれば Some("ABC")、2 であれば Some(123)、3 であれば Some(null)、それ以外であれば None を返却します。</p>
<pre class="c">
object main {
  def main(args: Array[String]) {
    val map = Map(1-&gt;"ABC", 2-&gt;123, 3-&gt;null)
    println(map.get(1))		<span class="cm">// =&gt; Some("ABC")</span>
    println(map.get(2))		<span class="cm">// =&gt; Some(123)</span>
    println(map.get(3))		<span class="cm">// =&gt; Some(null)</span>
    println(map.get(4))		<span class="cm">// =&gt; None</span>
  }
}
</pre>
<p>値が存在する場合、値は <b>Some(</b>値<b>)</b> でラッピングされています。ラッピングされた値から中身の値を取り出すには、<b>.get</b>, <b>.getOrElse()</b>, <b>.orNull</b> などのメソッドを利用します。</p>
<pre class="c">
o = map.get(1)		<span class="cm">// Some(123) or None</span>
o.get			<span class="cm">// 123 or エラー</span>
o.getOrElse(-1)		<span class="cm">// 123 or -1</span>
o.orNull		<span class="cm">// 123 or null</span>
</pre>
</div>

<h4 id="array">配列(Array)</h4>
<div class="i">
<p><b>Array</b> は配列を扱います。</p>
<pre class="c">
var arr: <em>Array[String]</em> = <em>Array.empty</em>	<span class="cm">// 空配列を定義</span>
arr = <em>Array("A", "B", "C")</em>		<span class="cm">// ("A", "B", "C")の配列を定義</span>
arr = arr <em>:+</em> "D"			<span class="cm">// 末尾に "D" を追加</span>
arr = "@" <em>+:</em> arr			<span class="cm">// 先頭に "@" を追加</span>
println(arr<em>.length</em>)			<span class="cm">// 要素数を取得</span>
println(<em>arr(0)</em>)				<span class="cm">// 0番目の要素を参照</span>
<em>arr(0)</em> = "$"				<span class="cm">// 0番目の要素の値を "$" に変更</span>
<em>for (</em>a <em>&lt;-</em> arr<em>)</em> println(a)		<span class="cm">// 各要素をループで処理</span>
arr.<em>foreach(</em>a <em>=&gt;</em> print(a)<em>)</em>		<span class="cm">// 各要素をループで処理</span>
arr.<em>map(</em>n <em>=&gt;</em> n + n<em>)</em>			<span class="cm">// 各要素をループで処理した結果を返す</span>
var arr2 = Array.<em>ofDim[Int](</em>2, 3<em>)</em>	<span class="cm">// 多次元配列(2×3)の宣言</span>
arr2<em>(1)(2)</em> = 10002			<span class="cm">// 多次元配列への値設定</span>
</pre>
</div>

<h4 id="list">リスト(List)</h4>
<div class="i">
<p><b>List</b> はリストを扱います。</p>
<pre class="c">
var list = <em>Nil</em>				<span class="cm">// 空リストはNil</span>
list = <em>List[Int](</em>1, 2, 3<em>)</em>		<span class="cm">// リストを定義</span>
println(<em>list(0)</em>)			<span class="cm">// 0番目の要素を参照</span>
// list(0) = 10				<span class="cm">// イミュータブルなので変更はできない(エラー)</span>
list = 0 <em>::</em> list			<span class="cm">// リストの先頭に要素を追加</span>
list = list <em>++</em> List(4, 5)		<span class="cm">// リストの末尾にリストを追加</span>
list = list <em>:::</em> List(6, 7)		<span class="cm">// リストの末尾にリストを追加</span>
println(list.<em>length</em>)			<span class="cm">// 要素数を取得</span>
<em>for (</em>n <em>&lt;-</em> list<em>)</em> println(n)		<span class="cm">// 各要素をループで処理</span>
list.<em>foreach(</em>n <em>=&gt;</em> println(n)<em>)</em>		<span class="cm">// 各要素をループで処理</span>
var list2 = list.<em>map(</em>n <em>=&gt;</em> n * 2)	<span class="cm">// 各要素をループで処理した結果を返す</span>
</pre>
</div>

<h4 id="map">マップ(Map)</h4>
<div class="i">
<p><b>Map</b> はマップを扱います。マップでは、キーと値のリストを管理することができます。</p>
<pre class="c">
var map = <em>Map(</em>1<em>-&gt;</em>"Red", 2<em>-&gt;</em>"Green", 3<em>-&gt;</em>"Blue"<em>)</em>	<span class="cm">// マップを生成する</span>
println(<em>map(2)</em>)				<span class="cm">// キーが2の値を取得する =&gt; "Green"</span>
// println(map(4))			<span class="cm">// 存在しないキーを指定すると実行時エラー</span>
println(map<em>.get(2)</em>)			<span class="cm">// 値が存在すればSome(値)を、存在しなければNothingを返す</span>
</pre>
</div>

<h4 id="set">セット(Set)</h4>
<div class="i">
<p><b>Set</b> は値の集合を扱います。集合では重複値は排除されます。</p>
<pre class="c">
var set = <em>Set(</em>"Red", "Green", "Blue"<em>)</em>	<span class="cm">// セットを生成する</span>
set = set <em>+</em> "Yellow"			<span class="cm">// セットに "Yellow" を加える(+=も利用可)</span>
set = set <em>+</em> "Red"			<span class="cm">// セットに "Red" を加えるが既に存在するので何も変わらない</span>
set = set <em>-</em> "Red"			<span class="cm">// セットから "Red" を削除する(-=も利用可)</span>
</pre>
</div>

<pre class="c">
import scala.collection.mutable.ListBuffer
    var lb = ListBuffer[Int](1, 2, 3)
    println(lb(0))
    lb(0) = 1
    lb += 4
    0 +=: lb
    lb.update(1, 999)
    println(lb)
    lb.remove(2)
    println(lb)
    for (n &lt;- lb) print(n); println("")
    lb.foreach(n =&gt; println(n))
    var lb2 = lb.map(n =&gt; n * 2)
    println(lb2)
</pre>

<h4 id="tuple">タプル(TupleN)</h4>
<div class="i">
<p><b>タプル</b> は複数個の要素を持つ値です。Int 要素と String 要素を持つタプルの型は <b>Tuple2[Int, String]</b> と表されます。要素の個数に応じて <b>Tuple1</b>～<b>Tuple22</b> までを使用することができます。また、<b>Tuple2[Int, String]</b> は簡略的に <b>(Int, String)</b> と表すことができます。</p>
<pre class="c">
class Foo {
  def getErrorInfo(): <em>(Int, String)</em> = <em>(404, "Not Found")</em>
}

object main {
  def main(args: Array[String]) {
    var foo = new Foo()
    var <em>(err, msg)</em> = foo.getErrorInfo()
    println(err + " : " + msg)
  }
}
</pre>
</div>

<h4 id="type">型別名(type)</h4>
<div class="i">
<p><b>type</b> を用いて、型に別名をつけることができます。</p>
<pre class="c">
<em>type</em> Int16 = Short
<em>type</em> Int32 = Int
<em>type</em> Int64 = Long
</pre>
</div>

<h4 id="isinstanceof">クラス判定(isInstanceOf)</h4>
<div class="i">
<p><b>isInstanceOf[</b>クラス名<b>]</b> は、値が指定したクラス、またはそのサブクラスであるか否かを判定します。</p>
<pre class="c">
var n: Int = 123
n.<em>isInstanceOf[</em>Int<em>]</em>		<span class="cm">// =&gt; true</span>
n.<em>isInstanceOf[</em>Any<em>]</em>		<span class="cm">// =&gt; true</span>
</pre>
</div>

<h4 id="#asinstanceof">キャスト(asInstanceOf)</h4>
<div class="i">
<p><b>asInstanceOf[</b>クラス名<b>]</b> は、値を指定したクラスの値に変換(キャスト)します。</p>
<pre class="c">
var n1: Short = 123
var n2: Int = n1.<em>asInstanceOf[</em>Int<em>]</em>
</pre>
</div>

<h4 id="operators">演算子</h4>
<div class="i">
<p>演算子には下記などがあります。</p>
<pre class="c">
<i>expr1</i> <em>+</em> <i>expr2</i>		<span class="cm">// 加算</span>
<i>expr1</i> <em>-</em> <i>expr2</i>		<span class="cm">// 減算</span>
<i>expr1</i> <em>*</em> <i>expr2</i>		<span class="cm">// 乗算</span>
<i>expr1</i> <em>/</em> <i>expr2</i>		<span class="cm">// 除算</span>
<i>expr1</i> <em>%</em> <i>expr2</i>		<span class="cm">// 剰余</span>

<em>~</em><i>expr</i>			<span class="cm">// ビット演算(NOT:補数)</span>
<i>expr1</i> <em>&amp;</em> <i>expr2</i>		<span class="cm">// ビット演算(AND)</span>
<i>expr1</i> <em>|</em> <i>expr2</i>		<span class="cm">// ビット演算(OR)</span>
<i>expr1</i> <em>^</em> <i>expr2</i>		<span class="cm">// ビット演算(XOR)</span>
<i>expr1</i> <em>&lt;&lt;</em> <i>expr2</i>		<span class="cm">// ビット演算(左シフト)</span>
<i>expr1</i> <em>&gt;&gt;</em> <i>expr2</i>		<span class="cm">// ビット演算(右シフト)</span>
<i>expr1</i> <em>&gt;&gt;&gt;</em> <i>expr2</i>		<span class="cm">// ビット演算(符号なし右シフト)</span>

<i>expr1</i> <em>==</em> <i>expr2</i>		<span class="cm">// <i>expr1</i> と <i>expr2</i> が等しければ</span>
<i>expr1</i> <em>!=</em> <i>expr2</i>		<span class="cm">// <i>expr1</i> と <i>expr2</i> が等しくなければ</span>
<i>expr1</i> <em>&gt;</em> <i>expr2</i>		<span class="cm">// <i>expr1</i> が <i>expr2</i> より大きければ</span>
<i>expr1</i> <em>=&gt;</em> <i>expr2</i>		<span class="cm">// <i>expr1</i> が <i>expr2</i> 以上であれば</span>
<i>expr1</i> <em>&lt;</em> <i>expr2</i>		<span class="cm">// <i>expr1</i> が <i>expr2</i> より小さければ</span>
<i>expr1</i> <em>=&lt;</em> <i>expr2</i>		<span class="cm">// <i>expr1</i> が <i>expr2</i> 以下であれば</span>
<i>expr1</i> <em>eq</em> <i>expr2</i>		<span class="cm">// <i>expr1</i> と <i>expr2</i> が同一インスタンスであれば</span>
<i>expr1</i> <em>nq</em> <i>expr2</i>		<span class="cm">// <i>expr1</i> と <i>expr2</i> が同一インスタンスでなければ</span>

<em>!</em><i>expr</i>			<span class="cm">// NOT(<i>expr</i> がfalseであれば)</span>
<i>expr1</i> <em>&amp;&amp;</em> <i>expr2</i>		<span class="cm">// AND(<i>expr1</i> かつ <i>expr2</i> が true であれば)</span>
<i>expr1</i> <em>||</em> <i>expr2</i>		<span class="cm">// OR(<i>expr1</i> または <i>expr2</i> が true であれば)</span>

<i>var</i> <em>=</em> <i>expr</i>		<span class="cm">// 代入(代入式の戻り値は結果ではなくUnit)</span>
<i>var</i> <em>+=</em> <i>expr</i>		<span class="cm">// <i>var</i> = <i>var</i> + <i>expr</i> と等価</span>
<i>var</i> <em>-=</em> <i>expr</i>		<span class="cm">// <i>var</i> = <i>var</i> - <i>expr</i> と等価</span>
<i>var</i> <em>*=</em> <i>expr</i>		<span class="cm">// <i>var</i> = <i>var</i> * <i>expr</i> と等価</span>
<i>var</i> <em>/=</em> <i>expr</i>		<span class="cm">// <i>var</i> = <i>var</i> / <i>expr</i> と等価</span>
<i>var</i> <em>%=</em> <i>expr</i>		<span class="cm">// <i>var</i> = <i>var</i> % <i>expr</i> と等価</span>
<i>var</i> <em>&amp;=</em> <i>expr</i>		<span class="cm">// <i>var</i> = <i>var</i> &amp; <i>expr</i> と等価</span>
<i>var</i> <em>|=</em> <i>expr</i>		<span class="cm">// <i>var</i> = <i>var</i> | <i>expr</i> と等価</span>
<i>var</i> <em>^=</em> <i>expr</i>		<span class="cm">// <i>var</i> = <i>var</i> ^ <i>expr</i> と等価</span>
<i>var</i> <em>&lt;&lt;=</em> <i>expr</i>		<span class="cm">// <i>var</i> = <i>var</i> &lt;&lt; <i>expr</i> と等価</span>
<i>var</i> <em>&gt;&gt;=</em> <i>expr</i>		<span class="cm">// <i>var</i> = <i>var</i> &gt;&gt; <i>expr</i> と等価</span>
<i>var</i> <em>&gt;&gt;&gt;=</em> <i>expr</i>		<span class="cm">// <i>var</i> = <i>var</i> &gt;&gt;&gt; <i>expr</i> と等価</span>
</pre>
<p>Scala の演算子はすべてメソッドです。<b>obj.method(arg)</b> を <b>obj method arg</b> と記述することができます。下記の例では、<b>Year</b> オブジェクトに <b>add</b> と <b>+</b> という名前のメソッドを定義して使用しています。演算子とメソッドは同じものだということが分かるかと思います。</p>
<pre class="c">
class Year(year: Int) {
  def <em>add(</em>n: Int<em>)</em>: Int = this.year + n
  def <em>+(</em>n: Int<em>)</em>: Int = this.year + n
}
object main {
  def main(args: Array[String]) {
    var y = new Year(2000)
    println(<em>y.add(21)</em>)  <span class="cm">// =&gt; 2021</span>
    println(<em>y add 21</em>)   <span class="cm">// =&gt; 2021</span>
    println(<em>y.+(21)</em>)    <span class="cm">// =&gt; 2021</span>
    println(<em>y + 21</em>)     <span class="cm">// =&gt; 2021</span>
  }
}
</pre>
</div>

<h4 id="val_and_var">値(val)と変数(var)</h4>
<div class="i">
<p><b>val</b> は値(value)を定義します。値は固定値であり一度代入すると変更することができません。</p>
<pre class="c">
<em>val</em> a <em>=</em> 123		<span class="cm">// 値 a を定義し、初期値を 123 とする</span>
<em>val</em> b<em>: Int</em> = 123	<span class="cm">// 値 b を Int 型で定義し、初期値を 123 とする</span>
</pre>
<p><b>var</b> は変数(variable)を定義します。変数は変動値であり一度代入しても再代入することができます。</p>
<pre class="c">
<em>var</em> c <em>=</em> 123		<span class="cm">// 変数 c を定義し、初期値を 123 とする</span>
<em>var</em> d<em>: Int</em> = 123	<span class="cm">// 変数 d を Int 型で定義し、初期値を 123 とする</span>
</pre>
</div>

<h4 id="statement_and_expression">文と式</h4>
<div class="i">
<p>値を返さないものを <b>文</b>(statement)、値を返すものを <b>式</b>(expression) と呼びます。前述の <a href="#val_and_var">val</a> や <a href="#val_and_var">var</a> は文、後述の <a href="#if">if</a> や <a href="javascript:if(confirm('http://www.tohoho-web.com/ex/while  \n\nļ޷ Teleport Ultra , Ϊ ļδҵ  \n\nڷϴ?'))window.location='http://www.tohoho-web.com/ex/while'" tppabs="http://www.tohoho-web.com/ex/while">while</a> などは式として定義されています。文や式の末尾にはセミコロン(<b>;</b>)を記述しますが、改行で区切られる場合は省略することも可能です。</p>
<pre class="c">
var a = 1; var b = 2; var c = a + b
println(a); println(b); println(c)
</pre>
</div>

<h4 id="block">ブロック式</h4>
<div class="i">
<p><b>{</b> と <b>}</b> の間に <b>;</b> または改行で区切った複数の式を記述することができます。</p>
<pre class="c">
<em>{</em> <i>expr1</i><em>;</em> <i>expr2</i><em>;</em> ... <em>}</em>
</pre>
</div>

<h4 id="if">if式</h4>
<div class="i">
<p><b>if</b> 式は、<i>expr1</i> が真であれば <i>expr2</i> を、偽であれば <i>expr3</i> を返します。</p>
<pre class="c">
<em>if (</em><i>expr1</i><em>)</em> <i>expr2</i>
<em>if (</em><i>expr1</i><em>)</em> <i>expr2</i> <em>else</em> <i>expr3</i>
</pre>
<p>使用例を下記に示します。</p>
<pre class="c">
var x = 123
<em>if (</em>x == 123<em>)</em>
  println("OK")
<em>else</em>
  println("NG")
</pre>
<p>式として定義されているため、下記の様に値を返すことができます。</p>
<pre class="c">
var a = 5
var x = if (a &gt; 3) "BIG" else "SMALL"
println(x)			<span class="cm">// =&gt; BIG</span>
</pre>
</div>

<h4 id="while">while式</h4>
<div class="i">
<p><b>while</b> 式は、<i>expr1</i> が真である間、<i>expr2</i> を実行します。</p>
<pre class="c">
<em>while (</em><i>expr1</i><em>)</em> <i>expr2</i>
</pre>
<p>使用例を下記に示します。</p>
<pre class="c">
var n = 5
<em>while (</em>n &lt; 0<em>) {</em>
  println(n)
  n = n - 1
<em>}</em>
</pre>
</div>

<h4 id="do">do～while式</h4>
<div class="i">
<p><b>do</b> ～ <b>while</b> 式は、<i>expr2</i> が真である間 <i>expr1</i> を実行します。</p>
<pre class="c">
<em>do</em> <i>expr1</i> <em>while (</em><i>expr2</i><em>)</em>
</pre>
<p>使用例を下記に示します。</p>
<pre class="c">
var n = 0
<em>do</em> {
  println(n)
  n += 1
} <em>while (</em>n &lt; 5<em>)</em>
</pre>
</div>

<h4 id="for">for式</h4>
<div class="i">
<p><b>for</b> 式は、<i>collection</i> の一つ一つを <i>var</i> に代入しながら <i>expr</i> を実行します。</p>
<pre class="c">
<em>for (</em><i>var</i> <em>&lt;-</em> <i>collection</i><em>)</em> <i>expr</i>
</pre>
<p>使用例をいくつか紹介します。</p>
<pre class="c">
<em>for (</em>i <em>&lt;-</em> 1 <em>to</em> 10<em>)</em> println(i)			<span class="cm">// 1～10 まで10回繰り返す</span>
for (i &lt;- 1 <em>until</em> 10) println(i)		<span class="cm">// 1～9 まで9回繰り返す</span>
for (i &lt;- 0 to 10 <em>by 2</em>) println(i)		<span class="cm">// 0, 2, 4, 6, 8, 10 まで繰り返す</span>
for (i &lt;- 10 to 1 <em>by -1</em>) println(i)		<span class="cm">// 10～1 まで10回繰り返す</span>
for (s &lt;- <em>Array("A", "B", "C")</em>) println(s)	<span class="cm">// A, B, C について繰り返す</span>
</pre>
<p>下記の様に if条件を記述することができます。</p>
<pre class="c">
for (i &lt;- 1 to 10 <em>if i % 2 == 0</em>) println(i)
for (i &lt;- 1 to 10 <em>if i % 2 == 0; if i % 3 == 0</em>) println(i)
</pre>
<p>for 式は通常 Unit () しか返却しませんが、<b>yield</b> を用いて新しいコレクションを返却することができます。</p>
<pre class="c">
val list = Array("A", "B", "C")
val list2 = for (s &lt;- list) <em>yield s + s</em>
for (s &lt;- list2) println(s)		<span class="cm">// =&gt; "AA", "BB", "CC"</span>
</pre>
<p>下記の様にして二重ループをひとつの for式で記述することができます。</p>
<pre class="c">
for (i &lt;- 1 to 2; j &lt;- 1 to 3) println(i * 100 + j)	<span class="cm">// =&gt; 101, 102, 103, 201, 202, 203</span>
</pre>
</div>

<h4 id="match">マッチ式(match)</h4>
<div class="i">
<p><b>match</b> は <b>case</b> にマッチした値を返します。</p>
<pre class="c">
object main {
  def main(args: Array[String]) {
    val msg = 2 <em>match</em> {
      <em>case</em> 1 <em>=&gt;</em> "One"
      <em>case</em> 2 <em>=&gt;</em> "Two"
      <em>case</em> 3 <em>=&gt;</em> "Three"
      <em>case</em> _ <em>=&gt;</em> "More"
    }
    println(msg)	<span class="cm">// =&gt; Two</span>
  }
}
</pre>
<p><b>|</b> で条件を複数記述することができます。下記では 1 または 2 であれば "Small" を、さもなくば "Big" を返します。</p>
<pre class="c">
val msg = 2 match {
  case <em>1 | 2</em> =&gt; "Small"
  case _ =&gt; "Big"
}
</pre>
<p><b>ガード条件</b> と呼ばれる if 条件を記述することもできます。</p>
<pre class="c">
var msg = 2 match {
  case n <em>if n &lt; 5</em>  => "Small"
  case n <em>if n == 5</em> => "Equal"
  case n <em>if n &gt; 5</em>  => "Big"
}
</pre>
<p>型によってマッチングさせることもできます。</p>
<pre class="c">
def getValue(value: Any) = {
  value match {
    case n<em>: Int</em>    =&gt; "Int: " + n
    case s<em>: String</em> =&gt; "String: " + s
    case _         =&gt; "Unknown"
  }
}
</pre>
</div>

<h4 id="try_catch">例外処理(throw, try, catch, finally)</h4>
<div class="i">
<p>Java や C# 等と同様、例外処理を記述することができます。<b>throw</b> はエラー発生時に <b>Exception</b> から派生する例外オブジェクトを投げます。<b>try</b> は例外を受け取る範囲を指定します。<b>catch</b> には例外を受け取った時の処理を記述します。<b>finally</b> には例外の有無に関わらず常に実行する処理を記述します。</p>
<pre class="c">
<em>try</em> {
  <em>throw</em> new IllegalArgumentException("arg1")
} <em>catch</em> {
  <em>case</em> e: IllegalArgumentException => println("IllegalArgumentException")
  <em>case</em> e: Exception => println("Unknown Exception")
} <em>finally</em> {
  println("Finally")
}
</pre>
</div>

<h4 id="function">関数(=&gt;)</h4>
<div class="i">
<p><b>=&gt;</b> は <b>関数</b>(function)を定義します。下記では、x と y を引数として受け取り、その合計を返却する関数を定義しています。</p>
<pre class="c">
val add = <em>(</em>x: Int, y: Int<em>)</em> <em>=&gt;</em> x + y
</pre>
</div>

<h4 id="method">メソッド(def)</h4>
<div class="i">
<p><b>def</b> は <b>メソッド</b>(method)を定義します。下記では、x と y を引数として受け取り、その合計を返却するメソッドを定義しています。関数とメソッドは似ていますが、メソッドはオブジェクトと紐づいて <b>this</b> によりオブジェクトを参照できるなどの差異があります。</p>
<pre class="c">
<em>def</em> add<em>(</em>x: Int, y: Int<em>):</em> Int = x + y
</pre>
<p><b>return</b> はメソッドの戻り値を指定しますが、{ ... } の最後の式が自動的に戻り値となるため、あまり使用されません。下記の <b>addA()</b> と <b>addB()</b> は結局同じ結果となります。</p>
<pre class="c">
def addA(x: Int, y: Int): Int = {
  x + y
}
def addB(x: Int, y: Int): Int = {
  <em>return</em> x + y
}
</pre>
<p><b>Unit</b> という型は何も返さないことを意味します。C言語系の <b>void</b> と同じようなものです。</p>
<pre class="c">
def func(msg: Int): <em>Unit</em> = println(msg)
</pre>
<p>メソッドにはデフォルト値を指定することができます。名前を指定して引数を渡すこともできます。</p>
<pre class="c">
object main {
  def func(name: String <em>= "(unknown)"</em>, age: Int <em>= -1</em>): Unit = {
    println(name + "(" + age + ")")
  }

  def main(args: Array[String]) {
    func("Yamada", 26)	<span class="cm">// Yamada(26)</span>
    func("Yamada")	<span class="cm">// Yamada(-1)</span>
    func(age = 26)	<span class="cm">// (unknown)(26)</span>
  }
}
</pre>
</div>

<h4 id="higher-order">高階関数</h4>
<div class="i">
<p>Scala は <b>高階関数</b>(higher-order function) をサポートしており、関数やメソッドを変数に代入したり、関数やメソッドの引数や戻り値に指定したりすることができます。下記の doFunc() は、第一引数で指定した回数分、第二引数で指定したメソッドを実行しています。</p>
<pre class="c">
object main {
  def hello(): Unit = println("Hello")
  def doFunc(n: Int, fn: () =&gt; Unit): Unit = {
    for (i &lt;- 1 to n) fn()
  }

  def main(args: Array[String]) {
    doFunc(5, hello)
  }
}
</pre>
</div>

<h4 id="by-name_parameters">名前渡しパラメータ</h4>
<div class="i">
<p>引数と型の間に <b>=&gt;</b> をつけるとそのパラメータは使用されるまで評価されません。下記は n回ループするという処理を実装するものですが、stmt は n が 0 の時には一度も実行されずにすみます。何故「名前渡し」と呼ぶのかよく分かりませんが、値渡しではなく、参照としての名前のみを渡しておき、必要になった時に名前からその値を得ているのかと思います。</p>
<pre class="c">
def loop(n: Int)(stmt: <em>=&gt;</em> Unit): Unit = {
  if (n &gt; 0) {
    stmt
    loop(n - 1) { stmt }
  }
}
loop(5) {
  println("A")
}
</pre>
</div>

<h4 id="class">クラス(class)</h4>
<div class="i">
<p><b>class</b> はクラスを定義します。<b>new</b> はクラスのインスタンスを作成します。</p>
<pre class="c">
<em>class</em> Person
var p = <em>new</em> Person
</pre>
<p>クラスのコンストラクタで属性を設定することもできます。属性値は下記の様にデフォルト値を設定することもできます。</p>
<pre class="c">
class Person<em>(name: String, age: Int = -1)</em>
var p1 = new Person<em>("Yamada", 26)</em>
var p2 = new Person<em>("Tanaka")</em>
</pre>
<p>クラスはメソッドを持つことができます。</p>
<pre class="c">
class Person(name: String, age: Int) {
  def <em>getName():</em> String = this.name
  def <em>getAge():</em> Int = this.age
}
var p = new Person("Yamada", 26)
println(p.getName())
println(p.getAge())
</pre>
<p>属性に <b>val</b> をつけると getter が、<b>var</b> をつけると getter/setter が自動生成され、<b>.</b>属性名 でアクセスできるようになります。</p>
<pre class="c">
class Person(<em>var</em> name: String, <em>var</em> age: Int)
var p = new Person("Yamada", 26)
p<em>.name</em> = "Tanaka"
println(p<em>.name</em>)
</pre>
<p>getter/setter を下記の様に定義することもできます。</p>
<pre class="c">
class Person {
  private var _name = "(unknown)"
  private var _age = -1
  def <em>name</em> = _name
  def <em>name_=</em> (newName: String): Unit = _name = newName
  def <em>age</em> = _age
  def <em>age_=</em> (newAge: Int): Unit = _age = newAge
}

object main {
  def main(args: Array[String]) {
    val p = new Person
    p.name = "Yamada"
    p.age = 26
    println(p.name)
    println(p.age)
  }
}
</pre>
</div>

<h4 id="extends">クラスの継承(extends)</h4>
<div class="i">
<p><b>extends</b> を用いてクラスを継承することができます。下記の例では ClassA を継承した ClassB を定義しています。継承したクラスでは、親クラスのメソッドを利用することが可能です。</p>
<pre class="c">
class ClassA {
  def foo(): Unit = println("ClassA")
}

class ClassB <em>extends ClassA</em> {
  def baa(): Unit = println("ClassB")
}

object main {
  def main(args: Array[String]) {
    val obj = new ClassB()
    obj.foo()
    obj.baa()
  }
}
</pre>
<p><b>override</b> を用いて親クラスのメソッドを上書きすることができます。</p>
<pre class="c">
class ClassB extends ClassA {
  <em>override</em> def foo(): Unit = println("ClassA!!!")
}
</pre>
</div>

<h4 id="final">クラス継承の禁止(final, sealed)</h4>
<div class="i">
<p><b>final</b> はクラスメソッドの継承やオーバーライドを禁止します。</p>
<pre class="c">
<em>final</em> class ClassA {			<span class="cm">// クラスの継承を禁止</span>
  def hello() = println("Hello")
}
class ClassB {
  <em>final</em> def hello() = println("Hello")	<span class="cm">// メソッドのオーバーライドを禁止</span>
}
</pre>
<p><b>sealed</b> は、クラスの継承を制限し、他のファイルに定義するサブクラスからの継承を禁止します。</p>
<pre class="c">
<em>sealed</em> class ClassA {			<span class="cm">// 他ファイル内のサブクラスからの継承を禁止する</span>
  def hello() = println("Hello")
}
</pre>
</div>

<h4 id="super">スーパークラス(super)</h4>
<div class="i">
<p><b>super</b> は親クラスを示します。下記の例で、サブクラスである <b>ClassB</b> の <b>action()</b> を呼び出すと、まず、そのスーパークラスである <b>ClassA</b> の <b>action()</b> を呼び出したのち、<b>ClassB</b> の <b>action()</b> 処理を継続します。</p>
<pre class="c">
class ClassB extends <em>ClassA</em> {
  override def action() {
    <em>super</em>.action()		<span class="cm">// ClassAのaction()</span>
    println("ClassB:action")
  }
}
</pre>
<p>多重継承を行っている場合、<b>super[</b>名前<b>]</b> で、対象とする親クラス(または <a href="#trait">トレイト</a>)を指定することができます。<b>[</b>名前<b>]</b> を省略すると、<b>extends</b> ... <b>with</b> ... で指定した一番最後のクラス(またはトレイト)が対象となります。</p>
<pre class="c">
class ClassC extends <em>ClassA</em> with <em>TraitB</em> {
  override def action() {
    <em>super[TraitB]</em>.action()	<span class="cm">// TraitBのaction()</span>
    <em>super[ClassA]</em>.action()	<span class="cm">// ClassAのaction()</span>
    <em>super</em>.action()		<span class="cm">// TraitBのaction()</span>
    println("ClassB:action")
  }
}
</pre>
</div>

<h4 id="access_modifires">アクセス修飾子(protected, private)</h4>
<div class="i">
<p>通常のメソッドはパブリック(public)になっておりアクセス制限はありません。<b>protected</b> はアクセス制限を自分自身のクラス、および、サブクラスからの参照のみに限定します。<b>private</b> は自分自身のクラスからの参照のみに限定します。</p>
<pre class="c">
class ClassA {
  def publicFunc() { println("publicFunc") }			<span class="cm">// publicメソッド</span>
  <em>protected</em> def protectedFunc() { println("protectedFunc") }	<span class="cm">// protectedメソッド</span>
  <em>private</em> def privateFunc() { println("privateFunc") }		<span class="cm">// privateメソッド</span>

  def funcA() {			<span class="cm">// 自分自身のクラスのメソッド</span>
    this.publicFunc()		<span class="cm">//   publicメソッドにアクセスできる</span>
    this.protectedFunc()	<span class="cm">//   protectedメソッドにアクセスできる</span>
    this.privateFunc()		<span class="cm">//   privateメソッドにアクセスできる</span>
  }
}

class ClassB extends ClassA {
  def funcB() {			<span class="cm">// サブクラスのメソッド</span>
    this.publicFunc()		<span class="cm">//   publicメソッドにアクセスできる</span>
    this.protectedFunc()	<span class="cm">//   protectedメソッドにアクセスできる</span>
    // this.private()		<span class="cm">//   privateメソッドにはアクセスできない(エラー)</span>
  }
}

class ClassC {
  def funcC() {
    var a = new ClassA()	<span class="cm">// 他のクラスのメソッド</span>
    a.publicFunc()		<span class="cm">//   publicメソッドにアクセスできる</span>
    // a.protectedFunc()	<span class="cm">//   protectedメソッドにはアクセスできない(エラー)</span>
    // a.privateFunc()		<span class="cm">//   privateメソッドにはアクセスできない(エラー)</span>
  }
}
</pre>
<p><b>protected[</b>パッケージ名<b>]</b> は、指定したパッケージおよびそのサブパッケージからの参照に限定します。<b>private[</b>パッケージ名<b>]</b> は、指定したパッケージ自信からの参照に限定します。</p>
<pre class="c">
package packageA {
  class ClassA {
    <em>protected[packageA]</em> def protectedXFunc() { println("protectedXFunc") }
    <em>private[packageA]</em> def privateXFunc() { println("privateXFunc") }
  }

  class ClassB {
    def funcB() {
      var d = new ClassA()		<span class="cm">// 自分自身のパッケージ</span>
      d.protectedXFunc()		<span class="cm">//   protected[X]メソッドにはアクセスできる</span>
      d.privateXFunc()			<span class="cm">//   private[X]メソッドにもアクセスできる</span>
    }
  }

  package packageC {
    class ClassC {
      def funcC() {
        var d = new ClassA()		<span class="cm">// サブパッケージ</span>
        d.protectedXFunc()		<span class="cm">//   protected[X]メソッドにはアクセスできる</span>
        // d.privateXFunc()		<span class="cm">//   private[X]メソッドにはアクセスできない(エラー)</span>
      }
    }
  }
}
</pre>
</div>

<h4 id="abstract">抽象クラス(abstract)</h4>
<div class="i">
<p><b>abstract</b> は <b>抽象クラス</b> を定義します。抽象クラスでは継承されることを前提に、サブクラスで実装されるメソッドの型のみを定義します。</p>
<pre class="c">
<em>abstract</em> class <em>Foo</em> {
  def hello(): Unit			<span class="cm">// 型のみを定義</span>
}
class Baa <em>extends Foo</em> {
  def hello(): Unit = println("Hello")	<span class="cm">// 実体を定義</span>
}
object main {
  def main(args: Array[String]) {
    var obj = new Baa()
    obj.hello()
  }
}
</pre>
</div>

<h4 id="type_parameter">型パラメータ</h4>
<div class="i">
<p>Java でいうジェネリック型を、Scala では <b>型パラメータ</b> と呼びます。型パラメータにより、フィールドやメソッドを様々な型に柔軟に対応させることができます。</p>
<pre class="c">
class Data<em>[A]</em>(var value: <em>A</em>) {
  def print(): Unit = println(value)
}

object main {
  def main(args: Array[String]) {
    var d1 = new Data<em>[Int]</em>(123)
    var d2 = new Data<em>[String]</em>("ABC")
    d1.print()
    d2.print()
  }
}
</pre>
</div>

<h4 id="case_class">ケースクラス(case)</h4>
<div class="i">
<p>Scala ではケースクラスという特別なクラスがあり、<b>new</b> 無しでもインスタンス化することができ、同じ属性値を持つケースクラスは等しいとみなされます。</p>
<pre class="c">
<em>case</em> class Point(x: Int, y: Int)
val p1 = Point(100, 200)
val p2 = Point(100, 200)
println(if (p1 == p2) "Equal" else "Not equal")	<span class="cm">// =&gt; Equal</span>
</pre>
</div>

<h4 id="object">オブジェクト(object)</h4>
<div class="i">
<p><b>object</b> はオブジェクトを定義します。クラスの場合は <b>class</b> でクラスを定義して <b>new</b> でそのインスタンスを生成しますが、<b>object</b> は唯一のインスタンス(<b>シングルトンオブジェクト</b>)を直接生成することができます。</p>
<pre class="c">
<em>object</em> Counter {
  private var counter = 0
  def countUp(): Unit = { counter += 1 }
  def getCount(): Int = counter
}
val cnt = Counter
cnt.countUp()
println(cnt.getCount())
</pre>
</div>

<h4 id="companion_object">コンパニオンオブジェクト</h4>
<div class="i">
<p>クラス名と同じ名前のオブジェクトはコンパニオンオブジェクトと呼ばれます。インスタンス化しなくても参照可能なスタティックフィールドやスタティックメソッドを定義することができます。</p>
<pre class="c">
class Math
<em>object Math</em> {
  val Pi = 3.14f
}
println(<em>Math.Pi</em>)
</pre>
</div>

<h4 id="apply">ファクトリメソッド(apply())</h4>
<div class="i">
<p><b>apply()</b> という名前のスタティックメソッドは、下記の様に省略形で呼び出すことができます。</p>
<pre class="c">
val u1 = <em>Person.apply("Yamada")</em>	<span class="cm">// 通常はこう呼び出すところを</span>
val u2 = <em>Person("Yamada)</em>	<span class="cm">// このように省略形で呼び出せる</span>
</pre>
<p>下記の様に<b>ファクトリメソッド</b>(インスタンス生成関数)としてよく使用されます。</p>
<pre class="c">
class Person(name: String)
<em>object Person</em> {
  def <em>apply</em>(name: String): Person = new Person(name)
}
object main {
  def main(args: Array[String]) {
    var p = <em>Person("Yamada")</em>
  }
}
</pre>
</div>

<h4 id="unapply">抽出子(unapply())</h4>
<div class="i">
<p><b>unapply()</b> という名前のメソッドは抽出子とも呼ばれ、None を返す可能性のある case文において Some(n) から値を抽出する際によく使用されます。例えば、Person オブジェクトから主要属性である name を取り出す getName() メソッドが Option[String] 型で定義され、None を返す可能性がある場合、次のように記述します。</p>
<pre class="c">
class Person(val name: String)
object Person {
  def apply(name: String): Person = new Person(name)
  def <em>getName(</em>p: Person<em>)</em>: Option[String] = if (p.name != "Unknown") Some(p.name) else None
}
object main {
  def main(args: Array[String]) {
    var p = Person("Yamada")
    var name = <em>Person.getName(p)</em> match {	<span class="cm">// p から主要属性 name を取り出す</span>
      case <em>Some(n)</em> => n				<span class="cm">// Some(値) であればその値</span>
      case _ => "(Unknown)"			<span class="cm">// さもなくば "(Unknown)" を返す</span>
    }
    println(name)
  }
}
</pre>
<p>オブジェクトから、その主要属性を Option[型] で返却するメソッドを <b>unapply()</b> という名前で定義することによって、これを、下記の様に直観的に記述することが可能となります。Some() も抽出子をサポートしているため、上記の様に呼び出すことができています。</p>
<pre class="c">
class Person(val name: String)
object Person {
  def apply(name: String): Person = new Person(name)
  def <em>unapply(</em>p: Person<em>)</em>: Option[String] = if (p.name != "Unknown") Some(p.name) else None
}
object main {
  def main(args: Array[String]) {
    var p = Person("Yamada")
    var name = <em>p</em> match {
      case <em>Person(n)</em> => n
      case _ => "(Unknown)"
    }
    println(name)
  }
}
</pre>
<p>抽出子を用意しておくことで、複数の型に対する case 文を利用可能になることもメリットです。</p>
<pre class="c">
var name = p match {
  case <em>Person(n)</em> => n
  case <em>Dog(n)</em> => n
  case <em>Cat(n)</em> => n
  case _ => "(Unknown)"
}
</pre>
</div>

<h4 id="trait">トレイト(trait)</h4>
<div class="i">
<p><b>trait</b> はトレイトを定義します。英語の trait は「特徴、特質」を意味します。Java のインタフェースに似たもので、トレイトを <b>extends</b> や <b>with</b> で継承するクラスが実装すべきフィールドやメソッドの型を定義します。</p>
<pre class="c">
<em>trait Shape</em> {
  def getArea(): Float	<span class="cm">// 面積を求める getArea() を実装しなくてはならないことを宣言</span>
}
class Rect(width: Float, height: Float) <em>extends Shape</em> {
  <em>override</em> def getArea(): Float = width * height
}
class Circle(r: Float) <em>extends Shape</em> {
  <em>override</em> def getArea(): Float = r * r * 3.14f
}
object main {
  def main(args: Array[String]) {
    val r1 = new Rect(100, 200)
    val c1 = new Circle(100)
    println(r1.getArea())
    println(c1.getArea())
  }
}
</pre>
<p>インタフェースと異なり、トレイトにはメソッドの実態を実装することもできます。</p>
<pre class="c">
trait Shape {
  def shape(): Unit<em> = println("Shape!")</em>
}
</pre>
</div>

<h4 id="mixin">ミックスイン(with)</h4>
<div class="i">
<p>クラスや抽象クラスはひとつしか継承することができませんが、トレイトは <b>with</b> によって多重継承・ミックスインさせることができます。</p>
<pre class="c">
trait Foo { def foo(): Unit = println("Foo") }
trait Baa { def baa(): Unit = println("Baa") }
trait Baz { def baz(): Unit = println("Baz") }
class ClassA <em>extends</em> Foo <em>with</em> Baa <em>with</em> Baz

object main {
  def main(args: Array[String]) {
    val obj = new ClassA()
    obj.foo(); obj.baa(); obj.baz()
  }
}
</pre>
</div>

<h4 id="implicit_conversion">暗黙の型変換(implicit)</h4>
<div class="i">
<p><b>implicit</b> で暗黙の型変換メソッドを定義することができます。Scala は型の扱いが厳格であり、if 文は Boolean しか許しません。下記の例では Boolean を指定すべき箇所に Int の値を指定しているため、コンパイルエラーとなります。</p>
<pre class="c">
object main {
  def main(args: Array[String]) {
    if (<em>1</em>) println("OK") else println("NG")	<span class="cm">// コンパイルエラー</span>
  }
}
</pre>
<p>下記の様にして、Int → Boolean への暗黙の型変換関数をスコープ内に定義しておいてやると、コンパイラが自動的にこの関数を組み込み、1 を true に変換してくれるようになります。</p>
<pre class="c">
<em>import scala.language.implicitConversions</em>
object main {
  <em>implicit def intToBoolean(n: Int): Boolean = n != 0</em>
  def main(args: Array[String]) {
    if (<em>1</em>) println("OK") else println("NG")	<span class="cm">// 暗黙の型変換により成功する</span>
  }
}
</pre>
<p>下記の例でも、String 型である "Yamada" は hello() というメソッドを持っていませんが、String から MyString への暗黙の型変換メソッドをコンパイラが自動的に適用してくれることで、MyString のメソッドである hello() を直接呼び出すことが可能になっています。</p>
<pre class="c">
<em>import scala.language.implicitConversions</em>
class MyString(val str: String) {
  def hello(): String = "Hello " + str
}
object main {
  <em>implicit def stringToMyString(arg: String): MyString = new MyString(arg)</em>
  def main(args: Array[String]) {
    println(<em>"Yamada".hello()</em>)
  }
}
</pre>
<p>Scala 2.10 からは <b>class</b> に直接 <b>implicit</b> を記述できるようになりました。</p>
<pre class="c">
import scala.language.implicitConversions
object main {
  <em>implicit</em> class MyString(val str: String) {
    def hello(): String = "Hello " + str
  }
  def main(args: Array[String]) {
    println(<em>"Yamada".hello()</em>)
  }
}
</pre>
</div>

<h4 id="implicit_parameter">暗黙のパラメータ(implicit)</h4>
<div class="i">
<p><b>implicit</b> はまた暗黙のパラメータにも使用されます。例えばデータベースにアクセスする多くのメソッドがデータベースへのコネクション <b>conn</b> を引数に持つ場合、下記の様に <b>conn</b> を暗黙のパラメータに指定することで、それぞれのメソッドで <b>conn</b> を省略することが可能となります。まず、省略しない場合のプログラムは下記の様になります。</p>
<pre class="c">
object main {
  def loadData(<em>conn: Connection</em>, dataId: Int): Data = { new Data }
  def saveData(<em>conn: Connection</em>, data: Data) = { println(data) }

  def main(args: Array[String]) {
    val conn = base.getConnection()
    var data = loadData(<em>conn</em>, 123)
    saveData(<em>conn</em>, data)
  }
}
</pre>
<p>これを、<b>implicit</b> で省略する形式に書き直すと下記の様になります。</p>
<pre class="c">
object main {
  def loadData(dataId: Int)<em>(implicit conn: Connection)</em>: Data = { new Data }
  def saveData(data: Data)<em>(implicit conn: Connection)</em> = { println(data) }

  def main(args: Array[String]) {
    <em>implicit</em> val conn = base.getConnection()	<span class="cm">// connを暗黙パラメータに指定</span>
    var data = loadData(123)			<span class="cm">// connを省略できる</span>
    saveData(data)				<span class="cm">// connを省略できる</span>
  }
}
</pre>
</div>

<h4 id="lazy">遅延評価(lazy)</h4>
<div class="i">
<p><b>lazy</b> は遅延評価を行います。遅延評価では、値が使用されるまで評価が行われません。下記の例では、<b>lazy</b> を指定しなければ、A, B, C, D の順番で出力されますが、<b>lazy</b> を指定すると a = funcA() は a が使用されるまで評価されず、B, A, C, D の順番で出力されます。</p>
<pre class="c">
object main {
  def funcA(s: String) = { println("A"); "A" }
  def funcC(s: String) = { println("C"); "C" }
  def main(args: Array[String]) {
    <em>lazy</em> val a = funcA("")	<span class="cm">// =&gt; "A"</span>
    println("B")		<span class="cm">// =&gt; "B"</span>
    funcC(a)			<span class="cm">// =&gt; "C"</span>
    println("D")		<span class="cm">// =&gt; "D"</span>
  }
}
</pre>
</div>

<h4 id="package">パッケージ(package)</h4>
<div class="i">
<p><b>package</b> はパッケージを定義します。</p>
<pre class="c">
<em>package users</em>
class User {
  def print() = println("User")
}
</pre>
<p>上記の内容を User.scala として作成し、下記の様にコンパイルすると、users ディレクトリとその配下に User.class ファイルが作成されます。</p>
<pre class="c">
$ scalac User.scala
$ ls -l users
total 4
-rw-r--r--. 1 foo   foo  676 Jan 3 12:45 User.class
</pre>
</div>

<h4 id="import">インポート(import)</h4>
<div class="i">
<p><b>import</b> はパッケージをインポートします。</p>
<pre class="c">
<em>import</em> users<em>._</em>			<span class="cm">// users 配下のすべてをインポートする</span>
import users.<em>User</em>		<span class="cm">// users 配下の User をインポートする</span>
import users.{User<em>, User2</em>}	<span class="cm">// User と User2 をインポートする</span>
import users.{User <em>=&gt; U</em>}	<span class="cm">// User を別名 U としてインポートする</span>
</pre>
</div>

<h4 id="variant">非変・共変・反変</h4>
<div class="i">
<p>通常の引数の型であれば、指定された型のサブクラスであればすべて許容されます。</p>
<pre class="c">
def foo(v: <em>AnyRef</em>) = println(v)
foo("ABC": String)		<span class="cm">// StringはAnyRefのサブクラスなので大丈夫</span>
</pre>
<p>しかし、型パラメータの場合はサブクラスであっても許可されません。これを <b>非変</b> と呼びます。</p>
<pre class="c">
class Foo[<em>T</em>](v: T)
class Baa(v: Foo[<em>AnyRef</em>])
val e = new Baa(new Foo[<em>String</em>]("ABC"))	<span class="cm">// StringはAnyRefのサブクラスだけどコンパイルエラー</span>
</pre>
<p><b>T</b> を <b>+T</b> とすることでサブクラスを指定することも許可できます。これを <b>共変</b> と呼びます。</p>
<pre class="c">
class Foo[<em>+T</em>](v: T)
class Baa(v: Foo[AnyRef])
val e = new Baa(new Foo[<em>String</em>]("ABC"))	<span class="cm">// サブクラスが許可されるようになる</span>
</pre>
<p><b>T</b> を <b>-T</b> とすることでスーパークラスを指定することも許可できます。これを <b>反変</b> と呼びます。</p>
<pre class="c">
class Foo[<em>-T</em>](v: T)
class Baa(v: Foo[AnyRef])
val e = new Baa(new Foo[<em>Any</em>]("ABC"))	<span class="cm">// スーパークラスが許可されるようになる</span>
</pre>
</div>

<h4 id="type_bounds">上限型境界と下限型境界</h4>
<div class="i">
<p>型パラメータでは任意の型 <b>T</b> を指定することができますが、<b> T &lt;: B</b> で <b>上限型境界</b>(Bおよびそのサブクラスに限定)を、<b>T &gt;: B</b> で <b>下限型境界</b>(Bおよびそのスーパークラスに限定)を指定することができます。上位型境界は単純に指定したクラスおよびサブクラスに限定したい時、下限型境界はリスト処理などで、ListNode[B] 型の .append() メソッドで B のスーパークラスを含めて処理したい場合などに利用されます。</p>
<pre class="c">
class A				<span class="cm">// クラスA</span>
class B extends A		<span class="cm">// クラスB(クラスAのサブクラス)</span>
class C extends B		<span class="cm">// クラスC(クラスBのサブクラス)</span>

class D[T]			<span class="cm">// 任意のクラスT</span>
class E[T <em>&lt;:</em> B]			<span class="cm">// 任意のクラスT(ただしB以下のクラス) -- 上限型境界</span>
class F[T <em>&gt;:</em> B]			<span class="cm">// 任意のクラスT(ただしB以上のクラス) -- 下限型境界</span>

val d1 = new D[A]		<span class="cm">// 任意のクラスなのでOK</span>
val d2 = new D[B]		<span class="cm">// 任意のクラスなのでOK</span>
val d3 = new D[C]		<span class="cm">// 任意のクラスなのでOK</span>

// val e1 = new E[A]		<span class="cm">// クラスB以下ではないのでエラー</span>
val e2 = new E[B]		<span class="cm">// クラスB以下なのでOK</span>
val e3 = new E[C]		<span class="cm">// クラスB以下なのでOK</span>

val f1 = new F[A]		<span class="cm">// クラスB以上なのでOK</span>
val f2 = new F[B]		<span class="cm">// クラスB以上なのでOK</span>
// val f3 = new F[C]		<span class="cm">// クラスB以上ではないのでエラー</span>
</pre>
</div>

<h4 id="annotation">アノテーション(@～)</h4>
<div class="i">
<p>コンパイラに対してアノテーション(付加情報)を指示することができます。<b>@deprecated</b> はそのメソッドが廃止予定であることを伝えます。</p>
<pre class="c">
<em>@deprecated("This method is deprecated", "2.10")</em>
def hello() = println("Hello")
</pre>
<p><b>@tailrc</b> はその関数が末尾再帰であることをコンパイラに伝えます。関数が末尾最適の条件を満たしていると再帰関数をスタック無しで呼び出せるように最適化されるため、メモリ枯渇やスタックオーバーフローの問題が低減されます。</p>
<pre class="c">
import scala.annotation.tailrec
<em>@tailrec</em>			<span class="cm">// fact1()は末尾最適ではないのでコンパイルエラー</span>
def fact1(n: Int): Int = {
  if (n == 0) 1 else n * fact1(n - 1)
}

<em>@tailrec</em>			<span class="cm">// fact2()は末尾最適なのでコンパイル成功</span>
def fact2(n: Int, s: Int = 1): Int = {
  if (n == 0) s else fact2(n - 1, s * n)
}
</pre>
<p><b>@unchecked</b> は、match において case が足りない旨の警告を抑止します。</p>
<pre class="c">
def fn(x: Option[String]) = (x: <em>@unchecked</em>) match {
  case Some(y) => y
  // case _ => ""	<span class="cm">// @unchecked無しの場合この行が無いと警告が出る</span>
}
</pre>
</div>

<h4 id="curry_and_partial">カリー化と部分適用</h4>
<div class="i">
<p><b>カリー化</b>とは、複数の引数を持つ関数を、「元の関数の第1引数」を引数として「残りの引数を引数として結果を返す関数」を戻り値とする関数に変換することをいいます。Scala は関数をカリー化するメソッド <b>curried</b> をサポートしています。</p>
<pre class="c">
var add = (x:Int, y:Int, z:Int) => x + y + z	<span class="cm">// x, y, zの合計を求める関数</span>
println(add(3, 4, 5))				<span class="cm">// =&gt; 12</span>
val curriedAdd = add<em>.curried</em>			<span class="cm">// .curried でカリー化する</span>
val curriedAdd2 = curriedAdd(3)			<span class="cm">// 第1引数を受け取り、残りの引数を受け取る関数を返す</span>
val curriedAdd3 = curriedAdd2(4)		<span class="cm">// 次の第1引数を受け取り、残りの引数を受け取る関数を返す</span>
println(curriedAdd3(5))				<span class="cm">// 残りの引数を受け取り、結果を返す =&gt; 12</span>
println(((curriedAdd(3))(4))(5))		<span class="cm">// このようにも呼び出せる =&gt; 12</span>
println(curriedAdd(3)(4)(5))			<span class="cm">// このようにも呼び出せる =&gt; 12</span>
</pre>
<p><b>部分適用</b> は、複数の引数を持つ関数に対して、一部の引数のみを渡して、残りの引数を受け取る関数を得ることを言います。</p>
<pre class="c">
var add = (x:Int, y:Int, z:Int) => x + y + z	<span class="cm">// x, y, zの合計を求める関数</span>
println(add(3, 4, 5))				<span class="cm">// =&gt; 12</span>
val partialAdd = add(_:Int, _:Int, 5)		<span class="cm">// 5だけ先に渡す</span>
println(partialAdd(3, 4))			<span class="cm">// 残りの引数を後から渡す =&gt; 12</span>
</pre>
</div>

<h4 id="xml">XMLリテラル</h4>
<div class="i">
<p>Scala では XML をリテラルとして扱うことができます。</p>
<pre class="c">
val xml =
  &lt;root&gt;
    &lt;items&gt;
      &lt;item&gt;&lt;name&gt;foo&lt;/name&gt;&lt;price&gt;120&lt;/price&gt;&lt;/item&gt;
      &lt;item&gt;&lt;name&gt;baa&lt;/name&gt;&lt;price&gt;320&lt;/price&gt;&lt;/item&gt;
      &lt;item&gt;&lt;name&gt;baz&lt;/name&gt;&lt;price&gt;640&lt;/price&gt;&lt;/item&gt;
    &lt;/items&gt;
  &lt;/root&gt;
</pre>
<p><b>{</b>...<b>}</b> の間には式を入れることができます。</p>
<pre class="c">
&lt;item&gt;&lt;name&gt;foo&lt;/name&gt;&lt;price&gt;<em>{fooPrice}</em>&lt;/price&gt;&lt;/item&gt;
</pre>
<p><b>\</b> はルート配下から子要素、孫要素を順次検索、<b>\\</b> は子孫要素の中からダイレクトに検索を行います。</p>
<pre class="c">
for (item &lt;- xml <em>\</em> "items" <em>\</em> "item") println(item)
for (item &lt;- xml <em>\\</em> "item") println(item)
</pre>
</div>

<h4 id="links">リンク</h4>
<div class="i">
<ul>
<li><a target="_top" href="javascript:if(confirm('https://www.scala-lang.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.scala-lang.org/'" tppabs="https://www.scala-lang.org/">Scala 本家サイト(英語)</a>
<li><a target="_top" href="javascript:if(confirm('https://docs.scala-lang.org/ja/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://docs.scala-lang.org/ja/'" tppabs="https://docs.scala-lang.org/ja/">Scala ドキュメント(日本語)</a>
<li><a target="_top" href="javascript:if(confirm('https://scala-lang.org/files/archive/spec/2.13/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://scala-lang.org/files/archive/spec/2.13/'" tppabs="https://scala-lang.org/files/archive/spec/2.13/">Scala 言語仕様(英語)</a>
<li><a target="_top" href="javascript:if(confirm('http://www.ne.jp/asahi/hishidama/home/tech/scala/index.html  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.ne.jp/asahi/hishidama/home/tech/scala/index.html'" tppabs="http://www.ne.jp/asahi/hishidama/home/tech/scala/index.html">ひしまださんのScalaメモ</a>
</ul>
</div>

<!--
○複数パラメータリスト(カリー化)
○部分適用
○マクロ:https://www.warski.org/blog/2012/12/starting-with-scala-macros-a-short-tutorial/
-->

<hr>
<div>Copyright (C) 2021 杜甫々</div>
<div>初版:2021年1月3日 最終更新:2021年1月3日</div>
<div>http://www.tohoho-web.com/ex/scala.html</div>
</body>
</html>
